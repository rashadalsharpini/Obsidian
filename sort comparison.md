best, average, worst.

|                | time complexity              | space complexity       | technique          |
| -------------- | ---------------------------- | ---------------------- | ------------------ |
| selection Sort | O(n^2)                       | O(1)                   | Brute Force        |
| bubble Sort    | O(n)/O(n^1)/O(n^1)           | O(1)                   | Brute Force        |
| quick Sort     | O(n log n)/O(n log n)/O(n^2) | O(log n)/O(log n)/O(n) | Divide and Conquer |
| merge Sort     | O(n log n)                   | O(n)                   | Divide and Conquer |
| insertion Sort | O(n)/O(n^2)/O(n^2)           | O(1)                   | Brute Force        |
| count Sort     | O(n + k)                     | O(k)                   | Special Case       |



---

|                    | pros                                                                                                                                                                                                         | cons                                                                                                                                                                                                                                                               |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| selection Sort     | - Stable sorting algorithm (preserves the order of equal elements).<br>- Low space complexity (O(1)).                                                                                                        | - Poor performance for large datasets (O(n^2) time complexity).<br>- Makes many comparisons and swaps, leading to inefficiency for larger arrays.                                                                                                                  |
| bubble Sort        | - Stable sorting algorithm.<br>- Low space complexity (O(1)).                                                                                                                                                | - Extremely inefficient for large datasets (O(n^2) time complexity in most cases).<br>- Makes many unnecessary comparisons and swaps, even when the array is partially sorted.                                                                                     |
| quick Sort<br>     | - Excellent average and best-case performance (O(n log n) time complexity).<br>- Efficient for large datasets due to its divide-and-conquer approach.                                                        | - Worst-case performance can be O(n^2), which occurs with a poorly chosen pivot element.<br>- Additional space complexity (O(log n) on average) due to the recursion stack.                                                                                        |
| merge Sort<br>     | - Guaranteed O(n log n) time complexity for all cases.<br>- Efficient for large datasets due to its divide-and-conquer approach.<br>- Stable sorting algorithm.                                              | - Requires additional space (O(n)) for the temporary array used during merging.<br>- Slightly more complex to implement compared to selection or bubble sort.                                                                                                      |
| insertion Sort<br> | - Efficient for small datasets or nearly sorted arrays (O(n) time complexity in these cases).<br>- Low space complexity (O(1)).<br>- Stable sorting algorithm.                                               | - Performance can degrade to O(n^2) for large datasets and randomly ordered arrays.<br>- Makes comparisons and shifts elements, which can be inefficient for very large arrays.                                                                                    |
| count Sort<br>     | - Excellent performance for data with a limited range of values (O(n + k) time complexity, where k is the range).<br>- Efficient for counting occurrences and placing elements directly in sorted positions. | - Space complexity can be high (O(k)) for datasets with a large range of values.<br>- Not suitable for general-purpose sorting due to the requirement of a limited value range.<br>- Not stable sorting algorithm (equal elements might not preserve their order). |
